#!/usr/bin/perl -s
# vim:set ts=4 sw=4 ai et smarttab:

# Calculates a mathematical expression the command line and prints the results.
# The expression is evaluated with perl, allowing for more ease and complexity
# than some other command line calculators, if you don't need things such as
# arbitrary precision.  Also very handy for parsing hex and binary numbers
# expressed as "0x" or "0b".  If symlinked and called as "hex", "oct", or
# "bin", prints the results in hex, octal, or binary.
#
# I use this at least several times every day.
#
#           -- Michael Toren <mct@toren.net>

use Math::Trig;

our($AUTOLOAD, $v, $V);

sub log_n {
    my $base = shift;
    my $num = shift;
    return log($num)/log($base);
}

sub log2  { log_n( 2, @_) }
sub log3  { log_n( 3, @_) }
sub log4  { log_n( 4, @_) }
sub log5  { log_n( 5, @_) }
sub log6  { log_n( 6, @_) }
sub log7  { log_n( 7, @_) }
sub log8  { log_n( 8, @_) }
sub log9  { log_n( 9, @_) }
sub log10 { log_n(10, @_) }

sub AUTOLOAD {
    if ($AUTOLOAD =~ /^main::log(\d+)$/) {
        return log_n($1, @_);
    }

    return undef;
}

my $last_result = 0;

sub calc {
    my $input = join " ", @_;
    return unless length $input > 0;

    # Expand commas to underscores, so "1,000" works like "1_000"
    $input =~ s/(\d) , (\d)/$1_$2/gx;
    
    # Expand "." to the last result
    $input =~ s/(^|[^\w]) \. ([^\w]|$)/$1$last_result$2/gx;

    print ">> [$input]\n" if $v;

    my $ret = eval { package sandbox; eval $input; };
    my $print;

    if ($0 =~ m/hex$/) {
        $print = sprintf "0x%X", $ret;
    }
    elsif ($0 =~ /bin$/) {
        $print = sprintf "0b%b", $ret;
    }
    elsif ($0 =~ /oct$/) {
        $print = sprintf "0%o", $ret;
    }
    else {
        $print = $ret;
    }

    unless (eval($print) eq $ret) {
        warn "Warning: Not numeric?  $ret\n";
    }
    else {
        $last_result = $ret;
    }

    print $print, "\n";
}

if (@ARGV) {
    calc @ARGV;
    exit;
}

while (<>) {
    chomp;
    calc $_;
}
